// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * Resource representing the custom login policy of an organization.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as zitadel from "@pulumiverse/zitadel";
 *
 * const _default = new zitadel.LoginPolicy("default", {
 *     orgId: data.zitadel_org["default"].id,
 *     userLogin: true,
 *     allowRegister: true,
 *     allowExternalIdp: true,
 *     forceMfa: false,
 *     forceMfaLocalOnly: false,
 *     passwordlessType: "PASSWORDLESS_TYPE_ALLOWED",
 *     hidePasswordReset: false,
 *     passwordCheckLifetime: "240h0m0s",
 *     externalLoginCheckLifetime: "240h0m0s",
 *     multiFactorCheckLifetime: "24h0m0s",
 *     mfaInitSkipLifetime: "720h0m0s",
 *     secondFactorCheckLifetime: "24h0m0s",
 *     ignoreUnknownUsernames: true,
 *     defaultRedirectUri: "localhost:8080",
 *     secondFactors: [
 *         "SECOND_FACTOR_TYPE_OTP",
 *         "SECOND_FACTOR_TYPE_U2F",
 *     ],
 *     multiFactors: ["MULTI_FACTOR_TYPE_U2F_WITH_VERIFICATION"],
 *     idps: [
 *         data.zitadel_idp_google["default"].id,
 *         data.zitadel_idp_azure_ad["default"].id,
 *     ],
 *     allowDomainDiscovery: true,
 *     disableLoginWithEmail: true,
 *     disableLoginWithPhone: true,
 * });
 * ```
 *
 * ## Import
 *
 * terraform The resource can be imported using the ID format `<[org_id]>`, e.g.
 *
 * ```sh
 *  $ pulumi import zitadel:index/loginPolicy:LoginPolicy imported '123456789012345678'
 * ```
 */
export class LoginPolicy extends pulumi.CustomResource {
    /**
     * Get an existing LoginPolicy resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: LoginPolicyState, opts?: pulumi.CustomResourceOptions): LoginPolicy {
        return new LoginPolicy(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'zitadel:index/loginPolicy:LoginPolicy';

    /**
     * Returns true if the given object is an instance of LoginPolicy.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is LoginPolicy {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === LoginPolicy.__pulumiType;
    }

    /**
     * if set to true, the suffix (@domain.com) of an unknown username input on the login screen will be matched against the org domains and will redirect to the registration of that organisation on success.
     */
    public readonly allowDomainDiscovery!: pulumi.Output<boolean | undefined>;
    /**
     * defines if a user is allowed to add a defined identity provider. E.g. Google auth
     */
    public readonly allowExternalIdp!: pulumi.Output<boolean>;
    /**
     * defines if a person is allowed to register a user on this organisation
     */
    public readonly allowRegister!: pulumi.Output<boolean>;
    /**
     * defines where the user will be redirected to if the login is started without app context (e.g. from mail)
     */
    public readonly defaultRedirectUri!: pulumi.Output<string>;
    /**
     * defines if user can additionally (to the loginname) be identified by their verified email address
     */
    public readonly disableLoginWithEmail!: pulumi.Output<boolean | undefined>;
    /**
     * defines if user can additionally (to the loginname) be identified by their verified phone number
     */
    public readonly disableLoginWithPhone!: pulumi.Output<boolean | undefined>;
    public readonly externalLoginCheckLifetime!: pulumi.Output<string>;
    /**
     * defines if a user MUST use a multi factor to log in
     */
    public readonly forceMfa!: pulumi.Output<boolean>;
    /**
     * if activated, ZITADEL only enforces MFA on local authentications. On authentications through MFA, ZITADEL won't prompt for MFA.
     */
    public readonly forceMfaLocalOnly!: pulumi.Output<boolean>;
    /**
     * defines if password reset link should be shown in the login screen
     */
    public readonly hidePasswordReset!: pulumi.Output<boolean>;
    /**
     * allowed idps to login or register
     */
    public readonly idps!: pulumi.Output<string[] | undefined>;
    /**
     * defines if unknown username on login screen directly return an error or always display the password screen
     */
    public readonly ignoreUnknownUsernames!: pulumi.Output<boolean>;
    public readonly mfaInitSkipLifetime!: pulumi.Output<string>;
    public readonly multiFactorCheckLifetime!: pulumi.Output<string>;
    /**
     * allowed multi factors
     */
    public readonly multiFactors!: pulumi.Output<string[] | undefined>;
    /**
     * ID of the organization
     */
    public readonly orgId!: pulumi.Output<string | undefined>;
    public readonly passwordCheckLifetime!: pulumi.Output<string>;
    /**
     * defines if passwordless is allowed for users
     */
    public readonly passwordlessType!: pulumi.Output<string>;
    public readonly secondFactorCheckLifetime!: pulumi.Output<string>;
    /**
     * allowed second factors
     */
    public readonly secondFactors!: pulumi.Output<string[] | undefined>;
    /**
     * defines if a user is allowed to login with his username and password
     */
    public readonly userLogin!: pulumi.Output<boolean>;

    /**
     * Create a LoginPolicy resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: LoginPolicyArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: LoginPolicyArgs | LoginPolicyState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as LoginPolicyState | undefined;
            resourceInputs["allowDomainDiscovery"] = state ? state.allowDomainDiscovery : undefined;
            resourceInputs["allowExternalIdp"] = state ? state.allowExternalIdp : undefined;
            resourceInputs["allowRegister"] = state ? state.allowRegister : undefined;
            resourceInputs["defaultRedirectUri"] = state ? state.defaultRedirectUri : undefined;
            resourceInputs["disableLoginWithEmail"] = state ? state.disableLoginWithEmail : undefined;
            resourceInputs["disableLoginWithPhone"] = state ? state.disableLoginWithPhone : undefined;
            resourceInputs["externalLoginCheckLifetime"] = state ? state.externalLoginCheckLifetime : undefined;
            resourceInputs["forceMfa"] = state ? state.forceMfa : undefined;
            resourceInputs["forceMfaLocalOnly"] = state ? state.forceMfaLocalOnly : undefined;
            resourceInputs["hidePasswordReset"] = state ? state.hidePasswordReset : undefined;
            resourceInputs["idps"] = state ? state.idps : undefined;
            resourceInputs["ignoreUnknownUsernames"] = state ? state.ignoreUnknownUsernames : undefined;
            resourceInputs["mfaInitSkipLifetime"] = state ? state.mfaInitSkipLifetime : undefined;
            resourceInputs["multiFactorCheckLifetime"] = state ? state.multiFactorCheckLifetime : undefined;
            resourceInputs["multiFactors"] = state ? state.multiFactors : undefined;
            resourceInputs["orgId"] = state ? state.orgId : undefined;
            resourceInputs["passwordCheckLifetime"] = state ? state.passwordCheckLifetime : undefined;
            resourceInputs["passwordlessType"] = state ? state.passwordlessType : undefined;
            resourceInputs["secondFactorCheckLifetime"] = state ? state.secondFactorCheckLifetime : undefined;
            resourceInputs["secondFactors"] = state ? state.secondFactors : undefined;
            resourceInputs["userLogin"] = state ? state.userLogin : undefined;
        } else {
            const args = argsOrState as LoginPolicyArgs | undefined;
            if ((!args || args.allowExternalIdp === undefined) && !opts.urn) {
                throw new Error("Missing required property 'allowExternalIdp'");
            }
            if ((!args || args.allowRegister === undefined) && !opts.urn) {
                throw new Error("Missing required property 'allowRegister'");
            }
            if ((!args || args.defaultRedirectUri === undefined) && !opts.urn) {
                throw new Error("Missing required property 'defaultRedirectUri'");
            }
            if ((!args || args.externalLoginCheckLifetime === undefined) && !opts.urn) {
                throw new Error("Missing required property 'externalLoginCheckLifetime'");
            }
            if ((!args || args.forceMfa === undefined) && !opts.urn) {
                throw new Error("Missing required property 'forceMfa'");
            }
            if ((!args || args.forceMfaLocalOnly === undefined) && !opts.urn) {
                throw new Error("Missing required property 'forceMfaLocalOnly'");
            }
            if ((!args || args.hidePasswordReset === undefined) && !opts.urn) {
                throw new Error("Missing required property 'hidePasswordReset'");
            }
            if ((!args || args.ignoreUnknownUsernames === undefined) && !opts.urn) {
                throw new Error("Missing required property 'ignoreUnknownUsernames'");
            }
            if ((!args || args.mfaInitSkipLifetime === undefined) && !opts.urn) {
                throw new Error("Missing required property 'mfaInitSkipLifetime'");
            }
            if ((!args || args.multiFactorCheckLifetime === undefined) && !opts.urn) {
                throw new Error("Missing required property 'multiFactorCheckLifetime'");
            }
            if ((!args || args.passwordCheckLifetime === undefined) && !opts.urn) {
                throw new Error("Missing required property 'passwordCheckLifetime'");
            }
            if ((!args || args.passwordlessType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'passwordlessType'");
            }
            if ((!args || args.secondFactorCheckLifetime === undefined) && !opts.urn) {
                throw new Error("Missing required property 'secondFactorCheckLifetime'");
            }
            if ((!args || args.userLogin === undefined) && !opts.urn) {
                throw new Error("Missing required property 'userLogin'");
            }
            resourceInputs["allowDomainDiscovery"] = args ? args.allowDomainDiscovery : undefined;
            resourceInputs["allowExternalIdp"] = args ? args.allowExternalIdp : undefined;
            resourceInputs["allowRegister"] = args ? args.allowRegister : undefined;
            resourceInputs["defaultRedirectUri"] = args ? args.defaultRedirectUri : undefined;
            resourceInputs["disableLoginWithEmail"] = args ? args.disableLoginWithEmail : undefined;
            resourceInputs["disableLoginWithPhone"] = args ? args.disableLoginWithPhone : undefined;
            resourceInputs["externalLoginCheckLifetime"] = args ? args.externalLoginCheckLifetime : undefined;
            resourceInputs["forceMfa"] = args ? args.forceMfa : undefined;
            resourceInputs["forceMfaLocalOnly"] = args ? args.forceMfaLocalOnly : undefined;
            resourceInputs["hidePasswordReset"] = args ? args.hidePasswordReset : undefined;
            resourceInputs["idps"] = args ? args.idps : undefined;
            resourceInputs["ignoreUnknownUsernames"] = args ? args.ignoreUnknownUsernames : undefined;
            resourceInputs["mfaInitSkipLifetime"] = args ? args.mfaInitSkipLifetime : undefined;
            resourceInputs["multiFactorCheckLifetime"] = args ? args.multiFactorCheckLifetime : undefined;
            resourceInputs["multiFactors"] = args ? args.multiFactors : undefined;
            resourceInputs["orgId"] = args ? args.orgId : undefined;
            resourceInputs["passwordCheckLifetime"] = args ? args.passwordCheckLifetime : undefined;
            resourceInputs["passwordlessType"] = args ? args.passwordlessType : undefined;
            resourceInputs["secondFactorCheckLifetime"] = args ? args.secondFactorCheckLifetime : undefined;
            resourceInputs["secondFactors"] = args ? args.secondFactors : undefined;
            resourceInputs["userLogin"] = args ? args.userLogin : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(LoginPolicy.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering LoginPolicy resources.
 */
export interface LoginPolicyState {
    /**
     * if set to true, the suffix (@domain.com) of an unknown username input on the login screen will be matched against the org domains and will redirect to the registration of that organisation on success.
     */
    allowDomainDiscovery?: pulumi.Input<boolean>;
    /**
     * defines if a user is allowed to add a defined identity provider. E.g. Google auth
     */
    allowExternalIdp?: pulumi.Input<boolean>;
    /**
     * defines if a person is allowed to register a user on this organisation
     */
    allowRegister?: pulumi.Input<boolean>;
    /**
     * defines where the user will be redirected to if the login is started without app context (e.g. from mail)
     */
    defaultRedirectUri?: pulumi.Input<string>;
    /**
     * defines if user can additionally (to the loginname) be identified by their verified email address
     */
    disableLoginWithEmail?: pulumi.Input<boolean>;
    /**
     * defines if user can additionally (to the loginname) be identified by their verified phone number
     */
    disableLoginWithPhone?: pulumi.Input<boolean>;
    externalLoginCheckLifetime?: pulumi.Input<string>;
    /**
     * defines if a user MUST use a multi factor to log in
     */
    forceMfa?: pulumi.Input<boolean>;
    /**
     * if activated, ZITADEL only enforces MFA on local authentications. On authentications through MFA, ZITADEL won't prompt for MFA.
     */
    forceMfaLocalOnly?: pulumi.Input<boolean>;
    /**
     * defines if password reset link should be shown in the login screen
     */
    hidePasswordReset?: pulumi.Input<boolean>;
    /**
     * allowed idps to login or register
     */
    idps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * defines if unknown username on login screen directly return an error or always display the password screen
     */
    ignoreUnknownUsernames?: pulumi.Input<boolean>;
    mfaInitSkipLifetime?: pulumi.Input<string>;
    multiFactorCheckLifetime?: pulumi.Input<string>;
    /**
     * allowed multi factors
     */
    multiFactors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * ID of the organization
     */
    orgId?: pulumi.Input<string>;
    passwordCheckLifetime?: pulumi.Input<string>;
    /**
     * defines if passwordless is allowed for users
     */
    passwordlessType?: pulumi.Input<string>;
    secondFactorCheckLifetime?: pulumi.Input<string>;
    /**
     * allowed second factors
     */
    secondFactors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * defines if a user is allowed to login with his username and password
     */
    userLogin?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a LoginPolicy resource.
 */
export interface LoginPolicyArgs {
    /**
     * if set to true, the suffix (@domain.com) of an unknown username input on the login screen will be matched against the org domains and will redirect to the registration of that organisation on success.
     */
    allowDomainDiscovery?: pulumi.Input<boolean>;
    /**
     * defines if a user is allowed to add a defined identity provider. E.g. Google auth
     */
    allowExternalIdp: pulumi.Input<boolean>;
    /**
     * defines if a person is allowed to register a user on this organisation
     */
    allowRegister: pulumi.Input<boolean>;
    /**
     * defines where the user will be redirected to if the login is started without app context (e.g. from mail)
     */
    defaultRedirectUri: pulumi.Input<string>;
    /**
     * defines if user can additionally (to the loginname) be identified by their verified email address
     */
    disableLoginWithEmail?: pulumi.Input<boolean>;
    /**
     * defines if user can additionally (to the loginname) be identified by their verified phone number
     */
    disableLoginWithPhone?: pulumi.Input<boolean>;
    externalLoginCheckLifetime: pulumi.Input<string>;
    /**
     * defines if a user MUST use a multi factor to log in
     */
    forceMfa: pulumi.Input<boolean>;
    /**
     * if activated, ZITADEL only enforces MFA on local authentications. On authentications through MFA, ZITADEL won't prompt for MFA.
     */
    forceMfaLocalOnly: pulumi.Input<boolean>;
    /**
     * defines if password reset link should be shown in the login screen
     */
    hidePasswordReset: pulumi.Input<boolean>;
    /**
     * allowed idps to login or register
     */
    idps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * defines if unknown username on login screen directly return an error or always display the password screen
     */
    ignoreUnknownUsernames: pulumi.Input<boolean>;
    mfaInitSkipLifetime: pulumi.Input<string>;
    multiFactorCheckLifetime: pulumi.Input<string>;
    /**
     * allowed multi factors
     */
    multiFactors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * ID of the organization
     */
    orgId?: pulumi.Input<string>;
    passwordCheckLifetime: pulumi.Input<string>;
    /**
     * defines if passwordless is allowed for users
     */
    passwordlessType: pulumi.Input<string>;
    secondFactorCheckLifetime: pulumi.Input<string>;
    /**
     * allowed second factors
     */
    secondFactors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * defines if a user is allowed to login with his username and password
     */
    userLogin: pulumi.Input<boolean>;
}
